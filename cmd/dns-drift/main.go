package main

import (
	"flag"
	"fmt"
	"os"

	// external packages
	"github.com/goccy/go-yaml"
	"github.com/miekg/dns"
	log "github.com/sirupsen/logrus"
)

const (
	AppVersion = "development"
)

func main() {
	// Command line arguments
	// var config, domain, nameserver string
	var verbose, version bool
	// flag.StringVar(&config, "config", "", "path to configuration file in YAML format containing the DNS records e.g. config/expected.yaml")
	// flag.StringVar(&domain, "domain", "", "domain name with the DNS records")
	// flag.StringVar(&nameserver, "nameserver", "", "nameserver to use for DNS resolution")
	flag.BoolVar(&version, "version", false, "outputs the version number for this application")
	flag.BoolVar(&verbose, "verbose", false, "Enables verbose output")

	flag.Parse()

	// print version and exit 0
	if version {
		fmt.Printf("%s\n", AppVersion)
		os.Exit(0)
	}

	// Set up logging
	log.SetFormatter(&log.TextFormatter{})
	log.SetFormatter(&log.TextFormatter{TimestampFormat: "2006-01-02 15:04:05", FullTimestamp: true})

	if verbose {
		log.SetLevel(log.DebugLevel)
	} else {
		log.SetLevel(log.InfoLevel)
	}

	// TODO: this could be improved by using the uncommented flag.StringVar() code above
	// However I'll abide by the projects requirements for positional arguments
	config := flag.Arg(0)
	domain := flag.Arg(1)
	nameserver := flag.Arg(2)

	// TODO: this would take the version or verbose flags as an argument, so this will not trigger if
	// `./dns-drift config domain -version` since the NArg is == 3
	if flag.NArg() < 3 {
		fmt.Println("Usage: dns-drift [--verbose, --version] <config> <domain> <nameserver>")
		os.Exit(1)
	}

	// Loads the YAML config file and
	dnsConfig, err := loadYAML(config)
	if err != nil {
		log.Fatal(err)
	}

	// Create a map that will hold the changes we need to write to changes.yaml
	changes := make(map[string]DNSYaml)

	// Loop through the keys and values in our YAML config file
	for d, dnsRecord := range *dnsConfig {
		domainQuery := fmt.Sprintf("%s.%s.", d, domain)
		dnsQuery := DNSQuery{
			Domain:     domainQuery,
			Type:       dnsRecord.Type,
			Nameserver: nameserver,
		}

		// Perform the DNS lookup and return the answer as DNSRecord struct
		dnsAnswer, err := dnsQuery.dnsLookup()
		if err != nil {
			log.Error(err)
		}

		// Compare the DNS answer compare to config file
		// TODO: I would add logic to compare the TTLs as well, but that's not in this project's scope
		if dnsAnswer.Value != dnsRecord.Value && dnsAnswer.Value == "" {
			log.Infof("‚ùå For domain %s: DNS query did not return an answer", domainQuery)
			change := &DNSYaml{
				Add: DNSChange{
					dnsAnswer.Value,
				},
				Delete: DNSChange{
					dnsRecord.Value,
				},
			}
			// Add the domain key and values to the changes map
			changes[d] = *change
		} else if dnsAnswer.Value != dnsRecord.Value {
			log.Infof("‚ö†Ô∏è For domain %s: DNS query '%s' does not match expected value '%s'", domainQuery, dnsAnswer.Value, dnsRecord.Value)
			change := &DNSYaml{
				Add: DNSChange{
					dnsAnswer.Value,
				},
				Delete: DNSChange{
					dnsRecord.Value,
				},
			}
			// Add the domain key and values to the changes map
			changes[d] = *change
		} else {
			log.Infof("‚úÖ For domain %s: DNS query '%s' matches expected value '%s'", domainQuery, dnsAnswer.Value, dnsRecord.Value)
		}
	}

	if len(changes) > 0 {
		// Write the changes to a YAML file
		f, err := os.Create("changes.yaml")
		if err != nil {
			log.Fatal(err)
		}

		defer f.Close()

		changeYAML, err := yaml.Marshal(changes)
		if err != nil {
			log.Error(err)
		}

		f.WriteString(fmt.Sprintf("# Zone changes for %s - Generated by dns-drift\n", domain))
		f.WriteString(string(changeYAML))
	}

	log.Info("üêô DNS check complete!")
}

// struct to hold data from YAML config file
type DNSRecord struct {
	TTL   uint32 `yaml:"ttl"`
	Type  string `yaml:"type"`
	Value string `yaml:"value"`
}

// Reads YAML config file and unmarshals it into a struct
func loadYAML(filePath string) (*map[string]DNSRecord, error) {

	// Open the YAML file
	yFile, err := os.ReadFile(filePath)
	if err != nil {
		log.Debugf("Cannot open YAML file: %s", filePath)
		return nil, err
	}

	// Unmarshal the YAML file into a struct
	yam := map[string]DNSRecord{}
	err = yaml.Unmarshal(yFile, &yam)
	if err != nil {
		return nil, err
	}

	log.Debugf("DNSRecord Struct is:\n%v\n", &yam)

	return &yam, nil
}

// Structs to handle changes to be written to the changes.yaml file
type DNSYaml struct {
	Add    DNSChange `yaml:"add"`
	Delete DNSChange `yaml:"delete"`
}

type DNSChange struct {
	Value string `yaml:"value"`
}

// Struct to hold data from DNS question
type DNSQuery struct {
	Domain     string
	Nameserver string
	Type       string
}

// Presents a DNS query to the nameserver and returns the response
func (q *DNSQuery) dnsLookup() (*DNSRecord, error) {

	// Construct the DNS question
	m1 := new(dns.Msg)
	m1.Id = dns.Id()
	m1.RecursionDesired = true
	m1.Question = make([]dns.Question, 1)
	m1.Question[0] = dns.Question{
		Name:   q.Domain,
		Qclass: dns.ClassINET,
	}

	// Set the question type for the DNS query
	switch {
	case q.Type == "A":
		m1.Question[0].Qtype = dns.TypeA
	case q.Type == "AAAA":
		m1.Question[0].Qtype = dns.TypeAAAA
	case q.Type == "CNAME":
		m1.Question[0].Qtype = dns.TypeCNAME
	case q.Type == "TXT":
		m1.Question[0].Qtype = dns.TypeTXT
	case q.Type == "PTR":
		m1.Question[0].Qtype = dns.TypePTR
	default:
		return nil, fmt.Errorf("invalid DNS query type: %s", q.Type)
	}

	// Performs the query with our question and nameserver
	in, err := dns.Exchange(m1, q.Nameserver+":53")
	if err != nil {
		return nil, err
	} else if in.Answer == nil {
		return &DNSRecord{}, nil
	}

	// Chooses the appropriate dns struct to handle the Answer so we can unmarshal it
	// TODO: I would also prefer to DRY up this case statement with the last one
	var value string
	switch {
	case q.Type == "A":
		value = in.Answer[0].(*dns.A).A.String()
	case q.Type == "AAAA":
		value = in.Answer[0].(*dns.AAAA).AAAA.String()
	case q.Type == "CNAME":
		value = in.Answer[0].(*dns.CNAME).Target
	case q.Type == "TXT":
		value = in.Answer[0].(*dns.TXT).Txt[0]
	case q.Type == "PTR":
		value = in.Answer[0].(*dns.PTR).Ptr
	}

	// Struct with the DNS answer
	dnsAnswer := &DNSRecord{
		TTL:   in.Answer[0].Header().Ttl,
		Type:  q.Type,
		Value: value,
	}

	return dnsAnswer, nil
}
